{"ast":null,"code":"var _jsxFileName = \"/Users/gyanmistry/SoftdevI/ASL-Study-Tool/ASLStudyTool/client/src/components/Deck.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState, useRef, createRef, useCallback } from 'react';\nimport Flashcard from './Flashcard';\nimport axios from 'axios';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport './Deck.css'; // We'll create this for the back button\nimport { LOCAL_STORAGE_STARRED_KEY } from './constants';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CARDS_PER_PAGE = 20; // Number of cards to display at once\n\nconst Deck = ({\n  deckId\n}) => {\n  _s();\n  const [cards, setCards] = useState([]);\n  const [visibleCards, setVisibleCards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [showInstructions, setShowInstructions] = useState(() => {\n    // Check localStorage for saved preference\n    const savedPreference = localStorage.getItem('showFlipInstructions');\n    return savedPreference === null ? true : savedPreference === 'true';\n  });\n  const [areAllFlipped, setAreAllFlipped] = useState(false);\n  const [highlightedCardId, setHighlightedCardId] = useState(null);\n  const [currentPage, setCurrentPage] = useState(1);\n  const [hasMoreCards, setHasMoreCards] = useState(true);\n  const [starredCardIds, setStarredCardIds] = useState([]);\n  const [loadingStarred, setLoadingStarred] = useState(true);\n  const navigate = useNavigate();\n  const location = useLocation();\n  const cardRefs = useRef([]);\n  const cardContainerRefs = useRef([]);\n  const observerRef = useRef(null);\n  const loadMoreTriggerRef = useRef(null);\n  let isStarToggleInProgress = false;\n\n  // Load starred cards\n  useEffect(() => {\n    const fetchStarredCards = async () => {\n      try {\n        // First try to get from localStorage for immediate UI update\n        const localStarred = localStorage.getItem(LOCAL_STORAGE_STARRED_KEY);\n        if (localStarred) {\n          try {\n            const parsedStarred = JSON.parse(localStarred);\n            console.log('Using starred cards from localStorage:', parsedStarred);\n            // Only update if we actually have stars (prevent overwriting with empty array)\n            if (parsedStarred && parsedStarred.length > 0) {\n              setStarredCardIds(parsedStarred);\n            }\n          } catch (parseErr) {\n            console.error('Error parsing starred cards from localStorage:', parseErr);\n            // Don't set to empty here, just continue to server\n          }\n        }\n\n        // Then try server\n        try {\n          const demoUserId = \"demo-user-id\"; // Hardcoded for demo\n          const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/users/${demoUserId}/starred-card-ids`);\n          if (response.data && response.data.cardIds && response.data.cardIds.length > 0) {\n            console.log('Got starred cards from server:', response.data.cardIds.length);\n            setStarredCardIds(response.data.cardIds);\n            // Always keep localStorage in sync with server\n            localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(response.data.cardIds));\n          }\n          // Important: If server returns empty but localStorage has values, keep the localStorage values\n          // This prevents accidentally clearing starred cards if server times out or returns empty\n        } catch (serverErr) {\n          console.error(\"Error fetching starred cards from server:\", serverErr);\n          // No action needed here since we already tried localStorage\n        }\n      } catch (err) {\n        console.error(\"Error in starred cards fetching logic:\", err);\n        // Keep any existing starred cards rather than setting to empty\n      } finally {\n        setLoadingStarred(false);\n      }\n    };\n    fetchStarredCards();\n  }, []);\n\n  // Function to refresh the starred cards with safeguards\n  const refreshStarredCards = async () => {\n    try {\n      console.log('Refreshing starred cards list');\n\n      // First check if we have local state with starred cards\n      if (starredCardIds.length > 0) {\n        console.log('Current starred cards in state:', starredCardIds);\n      }\n\n      // Check localStorage first\n      const localStarred = localStorage.getItem(LOCAL_STORAGE_STARRED_KEY);\n      let localStarredIds = [];\n      if (localStarred) {\n        try {\n          localStarredIds = JSON.parse(localStarred);\n          console.log('Found', localStarredIds.length, 'starred cards in localStorage');\n        } catch (parseErr) {\n          console.error('Error parsing localStorage starred cards:', parseErr);\n        }\n      }\n\n      // Try server \n      const demoUserId = \"demo-user-id\"; // Hardcoded for demo\n      try {\n        const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/users/${demoUserId}/starred-card-ids`);\n        if (response.data && response.data.cardIds && response.data.cardIds.length > 0) {\n          console.log('Refreshed starred cards from server:', response.data.cardIds.length);\n          // Only update if server returns non-empty array\n          setStarredCardIds(response.data.cardIds);\n          localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(response.data.cardIds));\n          return;\n        } else {\n          console.warn('Server returned empty starred cards list');\n          // If server returned empty but we have local data, keep the local data\n          if (localStarredIds.length > 0 || starredCardIds.length > 0) {\n            console.log('Using existing starred cards instead of empty server response');\n            if (localStarredIds.length > 0) {\n              setStarredCardIds(localStarredIds);\n            }\n            // No localStorage update needed here since we're keeping existing values\n            return;\n          }\n        }\n      } catch (serverErr) {\n        console.error(\"Error refreshing starred cards from server:\", serverErr);\n        // Fall back to localStorage if server fails\n      }\n\n      // If we get here and have localStorage data, use it\n      if (localStarredIds.length > 0) {\n        console.log('Using fallback starred cards from localStorage:', localStarredIds.length);\n        setStarredCardIds(localStarredIds);\n      }\n      // If all else fails, keep using current state - never clear starred cards accidentally\n    } catch (err) {\n      console.error(\"Error refreshing starred cards:\", err);\n      // Fail gracefully, don't change anything\n    }\n  };\n\n  // Handle starring/unstarring cards\n  const handleStarToggle = async (cardId, isStarred) => {\n    console.log(`Toggling star for card ${cardId} to ${isStarred ? 'starred' : 'unstarred'}`);\n\n    // Create a backup of the current starred IDs before making any changes\n    const previousStarredIds = [...starredCardIds];\n\n    // Backup current state to a different localStorage key as a safeguard\n    localStorage.setItem('asl_study_tool_starred_cards_backup', JSON.stringify(previousStarredIds));\n\n    // Update UI state immediately for responsiveness\n    let newStarredIds;\n    if (isStarred) {\n      newStarredIds = [...starredCardIds, cardId];\n      setStarredCardIds(newStarredIds);\n    } else {\n      newStarredIds = starredCardIds.filter(id => id !== cardId);\n      setStarredCardIds(newStarredIds);\n    }\n\n    // Save to localStorage immediately\n    localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(newStarredIds));\n\n    // Try to update the server as well (knowing it might fail)\n    try {\n      const demoUserId = \"demo-user-id\"; // Hardcoded for demo\n\n      if (isStarred) {\n        // Star the card\n        console.log(`Sending API request to star card ${cardId}`);\n        await axios.post(`${process.env.REACT_APP_API_URL}/api/cards/${cardId}/star`, {\n          userId: demoUserId\n        });\n        console.log('Star API request sent');\n      } else {\n        // Unstar the card\n        console.log(`Sending API request to unstar card ${cardId}`);\n        await axios.delete(`${process.env.REACT_APP_API_URL}/api/cards/${cardId}/star`, {\n          data: {\n            userId: demoUserId\n          }\n        });\n        console.log('Unstar API request sent');\n      }\n    } catch (err) {\n      console.error(`Error ${isStarred ? 'starring' : 'unstarring'} card on server:`, err);\n      console.log('Using localStorage for persistence instead');\n      // No need to revert UI state since we've already updated localStorage\n    }\n  };\n\n  // Load more cards when user scrolls near the bottom\n  const loadMoreCards = useCallback(() => {\n    if (!loading && hasMoreCards) {\n      const nextPage = currentPage + 1;\n      const startIndex = (nextPage - 1) * CARDS_PER_PAGE;\n      const endIndex = startIndex + CARDS_PER_PAGE;\n\n      // Check if we have more cards to load\n      if (startIndex < cards.length) {\n        const nextBatch = cards.slice(startIndex, endIndex);\n        setVisibleCards(prevCards => [...prevCards, ...nextBatch]);\n        setCurrentPage(nextPage);\n        setHasMoreCards(endIndex < cards.length);\n      } else {\n        setHasMoreCards(false);\n      }\n    }\n  }, [loading, hasMoreCards, currentPage, cards]);\n\n  // Set up intersection observer for infinite scrolling\n  useEffect(() => {\n    const options = {\n      root: null,\n      rootMargin: '100px',\n      threshold: 0.1\n    };\n    observerRef.current = new IntersectionObserver(entries => {\n      if (entries[0].isIntersecting) {\n        loadMoreCards();\n      }\n    }, options);\n    if (loadMoreTriggerRef.current) {\n      observerRef.current.observe(loadMoreTriggerRef.current);\n    }\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n    };\n  }, [loadMoreCards]);\n  useEffect(() => {\n    const fetchCards = async () => {\n      try {\n        // Special handling for \"all-starred\" deck ID\n        if (deckId === 'all-starred') {\n          console.log(\"Handling all-starred deck view\");\n\n          // Set a special title\n          document.title = \"All Starred Cards\";\n\n          // Check if we were passed starred card IDs in the location state\n          let starredIds = [];\n          if (location.state && location.state.starredCardIds) {\n            try {\n              const stateStarredIds = location.state.starredCardIds;\n              starredIds = typeof stateStarredIds === 'string' ? JSON.parse(stateStarredIds) : stateStarredIds;\n              console.log(\"Using starred IDs from location state:\", starredIds);\n            } catch (e) {\n              console.error(\"Error parsing starred IDs from location state:\", e);\n            }\n          }\n\n          // If no starred IDs in state, use our loaded starredCardIds\n          if (starredIds.length === 0) {\n            starredIds = starredCardIds;\n            console.log(\"Using loaded starred card IDs:\", starredIds);\n          }\n\n          // Get all decks\n          const usersResponse = await axios.get(`${process.env.REACT_APP_API_URL}/api/users`);\n          const demoUser = usersResponse.data.find(user => user.email === 'demo@example.com');\n          if (demoUser) {\n            const decksResponse = await axios.get(`${process.env.REACT_APP_API_URL}/api/decks/${demoUser.id}`);\n            const allDecks = decksResponse.data;\n            console.log(`Found ${allDecks.length} decks to search for starred cards`);\n\n            // Collect cards from all decks\n            let allCards = [];\n            for (const deck of allDecks) {\n              try {\n                const deckCardsResponse = await axios.get(`${process.env.REACT_APP_API_URL}/api/cards/${deck.id}`);\n                allCards = [...allCards, ...deckCardsResponse.data];\n              } catch (deckErr) {\n                console.error(`Error fetching cards for deck ${deck.id}:`, deckErr);\n              }\n            }\n            console.log(`Found total of ${allCards.length} cards across all decks`);\n\n            // Filter to starred cards only\n            const filteredCards = allCards.filter(card => starredIds.includes(card.id));\n            console.log(`Filtered to ${filteredCards.length} starred cards across all decks`);\n            setCards(filteredCards);\n\n            // Initialize with first page of cards\n            const initialCards = filteredCards.slice(0, CARDS_PER_PAGE);\n            setVisibleCards(initialCards);\n            setHasMoreCards(filteredCards.length > CARDS_PER_PAGE);\n\n            // Create refs for visible cards\n            cardRefs.current = Array(filteredCards.length).fill(null).map(() => /*#__PURE__*/createRef());\n            cardContainerRefs.current = Array(filteredCards.length).fill(null).map(() => /*#__PURE__*/createRef());\n          }\n          setLoading(false);\n          return; // Exit early\n        }\n\n        // Regular deck handling\n        const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/cards/${deckId}`);\n        const fetchedCards = response.data;\n        setCards(fetchedCards);\n\n        // Initialize with first page of cards\n        const initialCards = fetchedCards.slice(0, CARDS_PER_PAGE);\n        setVisibleCards(initialCards);\n        setHasMoreCards(fetchedCards.length > CARDS_PER_PAGE);\n\n        // Create refs for visible cards\n        cardRefs.current = Array(fetchedCards.length).fill(null).map(() => /*#__PURE__*/createRef());\n        cardContainerRefs.current = Array(fetchedCards.length).fill(null).map(() => /*#__PURE__*/createRef());\n        setLoading(false);\n\n        // Check if coming from search with a highlight card ID\n        if (location.state) {\n          const {\n            highlightCardId\n          } = location.state;\n          if (highlightCardId) {\n            setHighlightedCardId(highlightCardId);\n\n            // Find the card index\n            const cardIndex = fetchedCards.findIndex(card => card.id === highlightCardId);\n\n            // Calculate what page the card is on\n            if (cardIndex !== -1) {\n              const cardPage = Math.floor(cardIndex / CARDS_PER_PAGE) + 1;\n\n              // Load all pages up to the card's page\n              if (cardPage > 1) {\n                const cardsToShow = fetchedCards.slice(0, cardPage * CARDS_PER_PAGE);\n                setVisibleCards(cardsToShow);\n                setCurrentPage(cardPage);\n                setHasMoreCards(cardPage * CARDS_PER_PAGE < fetchedCards.length);\n              }\n\n              // Wait for rendering then scroll to the highlighted card\n              setTimeout(() => {\n                var _cardContainerRefs$cu;\n                if ((_cardContainerRefs$cu = cardContainerRefs.current[cardIndex]) !== null && _cardContainerRefs$cu !== void 0 && _cardContainerRefs$cu.current) {\n                  var _cardContainerRefs$cu2;\n                  (_cardContainerRefs$cu2 = cardContainerRefs.current[cardIndex].current) === null || _cardContainerRefs$cu2 === void 0 ? void 0 : _cardContainerRefs$cu2.scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'center'\n                  });\n                }\n              }, 300);\n            }\n          }\n        }\n      } catch (err) {\n        setError('Failed to load cards');\n        setLoading(false);\n      }\n    };\n    fetchCards();\n  }, [deckId, location.state]);\n  const handleBackClick = () => {\n    navigate('/');\n  };\n  const handleTestClick = () => {\n    console.log(\"Starting test mode with all cards\");\n\n    // Create a direct clone of cards to avoid API calls\n    try {\n      // Direct navigation with cards in state (avoid storage mechanisms)\n      console.log(`Directly passing ${cards.length} cards to test mode`);\n      navigate(`/test/${deckId}`, {\n        state: {\n          testMode: 'all',\n          cards: cards,\n          // Pass entire card array directly\n          deckId: deckId\n        }\n      });\n    } catch (err) {\n      console.error(\"Failed to start test mode:\", err);\n      // Fallback to simpler state\n      navigate(`/test/${deckId}`, {\n        state: {\n          testMode: 'all'\n        }\n      });\n    }\n  };\n  const handleStarredTestClick = () => {\n    console.log(\"Starting test mode with starred cards only\");\n\n    // Save starred card IDs to localStorage for backup\n    localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(starredCardIds));\n    try {\n      // Filter starred cards before navigation to avoid processing in TestMode\n      const starredCards = cards.filter(card => starredCardIds.includes(card.id));\n      console.log(`Found ${starredCards.length} starred cards to test`);\n\n      // Direct navigation with filtered cards in state\n      navigate(`/test/${deckId}`, {\n        state: {\n          starredOnly: true,\n          cards: starredCards,\n          // Pass already filtered cards\n          starredCardIds: starredCardIds,\n          deckId: deckId\n        }\n      });\n    } catch (err) {\n      console.error(\"Failed to start starred test mode:\", err);\n      // Fallback to simpler state\n      navigate(`/test/${deckId}`, {\n        state: {\n          starredOnly: true,\n          starredCardIds: starredCardIds\n        }\n      });\n    }\n  };\n  const handleFirstFlip = () => {\n    // When any card is flipped for the first time, hide instructions on all cards\n    setShowInstructions(false);\n    // Save preference to localStorage\n    localStorage.setItem('showFlipInstructions', 'false');\n  };\n  const handleFlipAll = () => {\n    const newFlipState = !areAllFlipped;\n    cardRefs.current.forEach(ref => {\n      if (ref.current) {\n        ref.current.flip(newFlipState);\n      }\n    });\n    setAreAllFlipped(newFlipState);\n  };\n  const handleCardInteraction = cardId => {\n    // Remove the highlighting when card is interacted with\n    setHighlightedCardId(null);\n  };\n\n  // Add a recovery function for starred cards\n  const recoverStarredCards = () => {\n    try {\n      console.log('Attempting to recover starred cards from backup');\n\n      // Try to get the backup\n      const backupStarred = localStorage.getItem('asl_study_tool_starred_cards_backup');\n      if (backupStarred) {\n        const parsedBackup = JSON.parse(backupStarred);\n        if (parsedBackup && parsedBackup.length > 0) {\n          console.log(`Found backup with ${parsedBackup.length} starred cards`);\n\n          // Restore to main storage\n          localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, backupStarred);\n\n          // Update state\n          setStarredCardIds(parsedBackup);\n          console.log('Successfully recovered starred cards from backup');\n          return true;\n        }\n      }\n      console.log('No valid backup found');\n      return false;\n    } catch (err) {\n      console.error('Error recovering starred cards from backup:', err);\n      return false;\n    }\n  };\n  if (loading) return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"loading-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"Loading...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 495,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 494,\n    columnNumber: 5\n  }, this);\n  if (error) return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"error-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [\"Error: \", error]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 501,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 500,\n    columnNumber: 5\n  }, this);\n\n  // Check if any cards are starred - add more debugging\n  const hasStarredCards = cards.some(card => starredCardIds.includes(card.id));\n  console.log(`Starred card IDs: ${starredCardIds.length > 0 ? starredCardIds.join(', ') : 'none'}`);\n  console.log(`Has starred cards: ${hasStarredCards}`);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"deck-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"back-button-container\",\n      children: /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"back-button\",\n        onClick: handleBackClick,\n        title: \"Back to Home\",\n        children: \"\\u2190\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 513,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 512,\n      columnNumber: 7\n    }, this), deckId === 'all-starred' && /*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"deck-title\",\n      children: \"All Starred Cards\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 520,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"deck-actions\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"action-buttons\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"deck-button\",\n          onClick: handleFlipAll,\n          title: areAllFlipped ? \"Show Videos\" : \"Show Answers\",\n          children: areAllFlipped ? \"Show Videos\" : \"Show Answers\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 525,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"deck-button\",\n          onClick: handleTestClick,\n          title: \"Start Test\",\n          children: \"Test All\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 528,\n          columnNumber: 11\n        }, this), starredCardIds.length > 0 && /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"deck-button starred-test-button\",\n          onClick: handleStarredTestClick,\n          title: \"Test Starred Cards Only\",\n          children: \"Test Starred\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 532,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"deck-button debug-button\",\n          onClick: refreshStarredCards,\n          title: \"Debug: Refresh Starred Cards\",\n          children: \"Refresh Stars\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 540,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 524,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 523,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"debug-info\",\n      style: {\n        padding: \"10px\",\n        background: \"#333\",\n        margin: \"10px\",\n        borderRadius: \"5px\",\n        fontSize: \"12px\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Starred IDs: \", starredCardIds.length > 0 ? starredCardIds.join(', ') : 'None']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 552,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Loading Starred: \", loadingStarred ? 'Yes' : 'No']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 553,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Deck Cards: \", cards.length]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 554,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: \"flex\",\n          gap: \"10px\",\n          marginTop: \"5px\"\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: refreshStarredCards,\n          style: {\n            padding: \"5px\",\n            fontSize: \"12px\"\n          },\n          children: \"Refresh Stars\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 556,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: recoverStarredCards,\n          style: {\n            padding: \"5px\",\n            fontSize: \"12px\",\n            background: \"#664646\",\n            color: \"white\"\n          },\n          children: \"Recover Starred\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 559,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 555,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 551,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"cards-grid\",\n      children: [visibleCards.map((card, index) => {\n        const cardIndex = cards.findIndex(c => c.id === card.id);\n        const isCardStarred = starredCardIds.includes(card.id);\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          ref: cardContainerRefs.current[cardIndex],\n          children: /*#__PURE__*/_jsxDEV(Flashcard, {\n            ref: cardRefs.current[cardIndex],\n            videoUrl: card.video_url,\n            answer: card.answer,\n            showInstructions: showInstructions,\n            onFirstFlip: handleFirstFlip,\n            isHighlighted: card.id === highlightedCardId,\n            onCardInteraction: handleCardInteraction,\n            cardId: card.id,\n            isStarred: isCardStarred,\n            onStarToggle: handleStarToggle\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 572,\n            columnNumber: 15\n          }, this)\n        }, card.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 571,\n          columnNumber: 13\n        }, this);\n      }), hasMoreCards && /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: loadMoreTriggerRef,\n        className: \"load-more-trigger\",\n        style: {\n          width: '100%',\n          height: '20px',\n          margin: '20px 0'\n        },\n        children: loading && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"loading-indicator\",\n          children: \"Loading more cards...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 595,\n          columnNumber: 25\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 590,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 565,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 511,\n    columnNumber: 5\n  }, this);\n};\n_s(Deck, \"1cDCEKde95X9YweFNgko6eo2kpg=\", false, function () {\n  return [useNavigate, useLocation];\n});\n_c = Deck;\nexport default Deck;\nvar _c;\n$RefreshReg$(_c, \"Deck\");","map":{"version":3,"names":["React","useEffect","useState","useRef","createRef","useCallback","Flashcard","axios","useNavigate","useLocation","LOCAL_STORAGE_STARRED_KEY","jsxDEV","_jsxDEV","CARDS_PER_PAGE","Deck","deckId","_s","cards","setCards","visibleCards","setVisibleCards","loading","setLoading","error","setError","showInstructions","setShowInstructions","savedPreference","localStorage","getItem","areAllFlipped","setAreAllFlipped","highlightedCardId","setHighlightedCardId","currentPage","setCurrentPage","hasMoreCards","setHasMoreCards","starredCardIds","setStarredCardIds","loadingStarred","setLoadingStarred","navigate","location","cardRefs","cardContainerRefs","observerRef","loadMoreTriggerRef","isStarToggleInProgress","fetchStarredCards","localStarred","parsedStarred","JSON","parse","console","log","length","parseErr","demoUserId","response","get","process","env","REACT_APP_API_URL","data","cardIds","setItem","stringify","serverErr","err","refreshStarredCards","localStarredIds","warn","handleStarToggle","cardId","isStarred","previousStarredIds","newStarredIds","filter","id","post","userId","delete","loadMoreCards","nextPage","startIndex","endIndex","nextBatch","slice","prevCards","options","root","rootMargin","threshold","current","IntersectionObserver","entries","isIntersecting","observe","disconnect","fetchCards","document","title","starredIds","state","stateStarredIds","e","usersResponse","demoUser","find","user","email","decksResponse","allDecks","allCards","deck","deckCardsResponse","deckErr","filteredCards","card","includes","initialCards","Array","fill","map","fetchedCards","highlightCardId","cardIndex","findIndex","cardPage","Math","floor","cardsToShow","setTimeout","_cardContainerRefs$cu","_cardContainerRefs$cu2","scrollIntoView","behavior","block","handleBackClick","handleTestClick","testMode","handleStarredTestClick","starredCards","starredOnly","handleFirstFlip","handleFlipAll","newFlipState","forEach","ref","flip","handleCardInteraction","recoverStarredCards","backupStarred","parsedBackup","className","children","fileName","_jsxFileName","lineNumber","columnNumber","hasStarredCards","some","join","onClick","style","padding","background","margin","borderRadius","fontSize","display","gap","marginTop","color","index","c","isCardStarred","videoUrl","video_url","answer","onFirstFlip","isHighlighted","onCardInteraction","onStarToggle","width","height","_c","$RefreshReg$"],"sources":["/Users/gyanmistry/SoftdevI/ASL-Study-Tool/ASLStudyTool/client/src/components/Deck.tsx"],"sourcesContent":["import React, { useEffect, useState, useRef, createRef, useCallback } from 'react';\nimport Flashcard, { FlashcardHandle } from './Flashcard';\nimport axios from 'axios';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport './Deck.css'; // We'll create this for the back button\nimport { LOCAL_STORAGE_STARRED_KEY } from './constants';\n\ninterface Card {\n  id: string;\n  video_url: string;\n  answer: string;\n  deck_id: string;\n}\n\ninterface DeckProps {\n  deckId: string;\n}\n\nconst CARDS_PER_PAGE = 20; // Number of cards to display at once\n\nconst Deck: React.FC<DeckProps> = ({ deckId }) => {\n  const [cards, setCards] = useState<Card[]>([]);\n  const [visibleCards, setVisibleCards] = useState<Card[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [showInstructions, setShowInstructions] = useState(() => {\n    // Check localStorage for saved preference\n    const savedPreference = localStorage.getItem('showFlipInstructions');\n    return savedPreference === null ? true : savedPreference === 'true';\n  });\n  const [areAllFlipped, setAreAllFlipped] = useState(false);\n  const [highlightedCardId, setHighlightedCardId] = useState<string | null>(null);\n  const [currentPage, setCurrentPage] = useState(1);\n  const [hasMoreCards, setHasMoreCards] = useState(true);\n  const [starredCardIds, setStarredCardIds] = useState<string[]>([]);\n  const [loadingStarred, setLoadingStarred] = useState(true);\n  const navigate = useNavigate();\n  const location = useLocation();\n  const cardRefs = useRef<(React.RefObject<FlashcardHandle>)[]>([]);\n  const cardContainerRefs = useRef<(React.RefObject<HTMLDivElement>)[]>([]);\n  const observerRef = useRef<IntersectionObserver | null>(null);\n  const loadMoreTriggerRef = useRef<HTMLDivElement>(null);\n  let isStarToggleInProgress = false;\n\n  // Load starred cards\n  useEffect(() => {\n    const fetchStarredCards = async () => {\n      try {\n        // First try to get from localStorage for immediate UI update\n        const localStarred = localStorage.getItem(LOCAL_STORAGE_STARRED_KEY);\n        if (localStarred) {\n          try {\n            const parsedStarred = JSON.parse(localStarred);\n            console.log('Using starred cards from localStorage:', parsedStarred);\n            // Only update if we actually have stars (prevent overwriting with empty array)\n            if (parsedStarred && parsedStarred.length > 0) {\n              setStarredCardIds(parsedStarred);\n            }\n          } catch (parseErr) {\n            console.error('Error parsing starred cards from localStorage:', parseErr);\n            // Don't set to empty here, just continue to server\n          }\n        }\n\n        // Then try server\n        try {\n          const demoUserId = \"demo-user-id\"; // Hardcoded for demo\n          const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/users/${demoUserId}/starred-card-ids`);\n          \n          if (response.data && response.data.cardIds && response.data.cardIds.length > 0) {\n            console.log('Got starred cards from server:', response.data.cardIds.length);\n            setStarredCardIds(response.data.cardIds);\n            // Always keep localStorage in sync with server\n            localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(response.data.cardIds));\n          }\n          // Important: If server returns empty but localStorage has values, keep the localStorage values\n          // This prevents accidentally clearing starred cards if server times out or returns empty\n        } catch (serverErr) {\n          console.error(\"Error fetching starred cards from server:\", serverErr);\n          // No action needed here since we already tried localStorage\n        }\n      } catch (err) {\n        console.error(\"Error in starred cards fetching logic:\", err);\n        // Keep any existing starred cards rather than setting to empty\n      } finally {\n        setLoadingStarred(false);\n      }\n    };\n\n    fetchStarredCards();\n  }, []);\n\n  // Function to refresh the starred cards with safeguards\n  const refreshStarredCards = async () => {\n    try {\n      console.log('Refreshing starred cards list');\n      \n      // First check if we have local state with starred cards\n      if (starredCardIds.length > 0) {\n        console.log('Current starred cards in state:', starredCardIds);\n      }\n      \n      // Check localStorage first\n      const localStarred = localStorage.getItem(LOCAL_STORAGE_STARRED_KEY);\n      let localStarredIds: string[] = [];\n      \n      if (localStarred) {\n        try {\n          localStarredIds = JSON.parse(localStarred);\n          console.log('Found', localStarredIds.length, 'starred cards in localStorage');\n        } catch (parseErr) {\n          console.error('Error parsing localStorage starred cards:', parseErr);\n        }\n      }\n      \n      // Try server \n      const demoUserId = \"demo-user-id\"; // Hardcoded for demo\n      try {\n        const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/users/${demoUserId}/starred-card-ids`);\n        \n        if (response.data && response.data.cardIds && response.data.cardIds.length > 0) {\n          console.log('Refreshed starred cards from server:', response.data.cardIds.length);\n          // Only update if server returns non-empty array\n          setStarredCardIds(response.data.cardIds);\n          localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(response.data.cardIds));\n          return;\n        } else {\n          console.warn('Server returned empty starred cards list');\n          // If server returned empty but we have local data, keep the local data\n          if (localStarredIds.length > 0 || starredCardIds.length > 0) {\n            console.log('Using existing starred cards instead of empty server response');\n            if (localStarredIds.length > 0) {\n              setStarredCardIds(localStarredIds);\n            }\n            // No localStorage update needed here since we're keeping existing values\n            return;\n          }\n        }\n      } catch (serverErr) {\n        console.error(\"Error refreshing starred cards from server:\", serverErr);\n        // Fall back to localStorage if server fails\n      }\n      \n      // If we get here and have localStorage data, use it\n      if (localStarredIds.length > 0) {\n        console.log('Using fallback starred cards from localStorage:', localStarredIds.length);\n        setStarredCardIds(localStarredIds);\n      }\n      // If all else fails, keep using current state - never clear starred cards accidentally\n    } catch (err) {\n      console.error(\"Error refreshing starred cards:\", err);\n      // Fail gracefully, don't change anything\n    }\n  };\n\n  // Handle starring/unstarring cards\n  const handleStarToggle = async (cardId: string, isStarred: boolean) => {\n    console.log(`Toggling star for card ${cardId} to ${isStarred ? 'starred' : 'unstarred'}`);\n    \n    // Create a backup of the current starred IDs before making any changes\n    const previousStarredIds = [...starredCardIds];\n    \n    // Backup current state to a different localStorage key as a safeguard\n    localStorage.setItem('asl_study_tool_starred_cards_backup', JSON.stringify(previousStarredIds));\n    \n    // Update UI state immediately for responsiveness\n    let newStarredIds;\n    if (isStarred) {\n      newStarredIds = [...starredCardIds, cardId];\n      setStarredCardIds(newStarredIds);\n    } else {\n      newStarredIds = starredCardIds.filter(id => id !== cardId);\n      setStarredCardIds(newStarredIds);\n    }\n    \n    // Save to localStorage immediately\n    localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(newStarredIds));\n    \n    // Try to update the server as well (knowing it might fail)\n    try {\n      const demoUserId = \"demo-user-id\"; // Hardcoded for demo\n      \n      if (isStarred) {\n        // Star the card\n        console.log(`Sending API request to star card ${cardId}`);\n        await axios.post(`${process.env.REACT_APP_API_URL}/api/cards/${cardId}/star`, { userId: demoUserId });\n        console.log('Star API request sent');\n      } else {\n        // Unstar the card\n        console.log(`Sending API request to unstar card ${cardId}`);\n        await axios.delete(`${process.env.REACT_APP_API_URL}/api/cards/${cardId}/star`, { \n          data: { userId: demoUserId } \n        });\n        console.log('Unstar API request sent');\n      }\n    } catch (err) {\n      console.error(`Error ${isStarred ? 'starring' : 'unstarring'} card on server:`, err);\n      console.log('Using localStorage for persistence instead');\n      // No need to revert UI state since we've already updated localStorage\n    }\n  };\n\n  // Load more cards when user scrolls near the bottom\n  const loadMoreCards = useCallback(() => {\n    if (!loading && hasMoreCards) {\n      const nextPage = currentPage + 1;\n      const startIndex = (nextPage - 1) * CARDS_PER_PAGE;\n      const endIndex = startIndex + CARDS_PER_PAGE;\n      \n      // Check if we have more cards to load\n      if (startIndex < cards.length) {\n        const nextBatch = cards.slice(startIndex, endIndex);\n        setVisibleCards(prevCards => [...prevCards, ...nextBatch]);\n        setCurrentPage(nextPage);\n        setHasMoreCards(endIndex < cards.length);\n      } else {\n        setHasMoreCards(false);\n      }\n    }\n  }, [loading, hasMoreCards, currentPage, cards]);\n\n  // Set up intersection observer for infinite scrolling\n  useEffect(() => {\n    const options = {\n      root: null,\n      rootMargin: '100px',\n      threshold: 0.1\n    };\n    \n    observerRef.current = new IntersectionObserver(entries => {\n      if (entries[0].isIntersecting) {\n        loadMoreCards();\n      }\n    }, options);\n    \n    if (loadMoreTriggerRef.current) {\n      observerRef.current.observe(loadMoreTriggerRef.current);\n    }\n    \n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n    };\n  }, [loadMoreCards]);\n\n  useEffect(() => {\n    const fetchCards = async () => {\n      try {\n        // Special handling for \"all-starred\" deck ID\n        if (deckId === 'all-starred') {\n          console.log(\"Handling all-starred deck view\");\n          \n          // Set a special title\n          document.title = \"All Starred Cards\";\n          \n          // Check if we were passed starred card IDs in the location state\n          let starredIds: string[] = [];\n          if (location.state && (location.state as any).starredCardIds) {\n            try {\n              const stateStarredIds = (location.state as any).starredCardIds;\n              starredIds = typeof stateStarredIds === 'string' ? \n                JSON.parse(stateStarredIds) : stateStarredIds;\n              console.log(\"Using starred IDs from location state:\", starredIds);\n            } catch (e) {\n              console.error(\"Error parsing starred IDs from location state:\", e);\n            }\n          }\n          \n          // If no starred IDs in state, use our loaded starredCardIds\n          if (starredIds.length === 0) {\n            starredIds = starredCardIds;\n            console.log(\"Using loaded starred card IDs:\", starredIds);\n          }\n          \n          // Get all decks\n          const usersResponse = await axios.get(`${process.env.REACT_APP_API_URL}/api/users`);\n          const demoUser = usersResponse.data.find((user: any) => user.email === 'demo@example.com');\n          \n          if (demoUser) {\n            const decksResponse = await axios.get(`${process.env.REACT_APP_API_URL}/api/decks/${demoUser.id}`);\n            const allDecks = decksResponse.data;\n            console.log(`Found ${allDecks.length} decks to search for starred cards`);\n            \n            // Collect cards from all decks\n            let allCards: Card[] = [];\n            for (const deck of allDecks) {\n              try {\n                const deckCardsResponse = await axios.get(`${process.env.REACT_APP_API_URL}/api/cards/${deck.id}`);\n                allCards = [...allCards, ...deckCardsResponse.data];\n              } catch (deckErr) {\n                console.error(`Error fetching cards for deck ${deck.id}:`, deckErr);\n              }\n            }\n            \n            console.log(`Found total of ${allCards.length} cards across all decks`);\n            \n            // Filter to starred cards only\n            const filteredCards = allCards.filter(card => starredIds.includes(card.id));\n            console.log(`Filtered to ${filteredCards.length} starred cards across all decks`);\n            \n            setCards(filteredCards);\n            \n            // Initialize with first page of cards\n            const initialCards = filteredCards.slice(0, CARDS_PER_PAGE);\n            setVisibleCards(initialCards);\n            setHasMoreCards(filteredCards.length > CARDS_PER_PAGE);\n            \n            // Create refs for visible cards\n            cardRefs.current = Array(filteredCards.length)\n              .fill(null)\n              .map(() => createRef<FlashcardHandle>() as React.RefObject<FlashcardHandle>);\n\n            cardContainerRefs.current = Array(filteredCards.length)\n              .fill(null)\n              .map(() => createRef<HTMLDivElement>() as React.RefObject<HTMLDivElement>);\n          }\n          \n          setLoading(false);\n          return; // Exit early\n        }\n        \n        // Regular deck handling\n        const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/cards/${deckId}`);\n        const fetchedCards = response.data;\n        setCards(fetchedCards);\n        \n        // Initialize with first page of cards\n        const initialCards = fetchedCards.slice(0, CARDS_PER_PAGE);\n        setVisibleCards(initialCards);\n        setHasMoreCards(fetchedCards.length > CARDS_PER_PAGE);\n        \n        // Create refs for visible cards\n        cardRefs.current = Array(fetchedCards.length)\n          .fill(null)\n          .map(() => createRef<FlashcardHandle>() as React.RefObject<FlashcardHandle>);\n\n        cardContainerRefs.current = Array(fetchedCards.length)\n          .fill(null)\n          .map(() => createRef<HTMLDivElement>() as React.RefObject<HTMLDivElement>);\n        \n        setLoading(false);\n        \n        // Check if coming from search with a highlight card ID\n        if (location.state) {\n          const { highlightCardId } = location.state as { fromSearch?: boolean, highlightCardId?: string };\n          \n          if (highlightCardId) {\n            setHighlightedCardId(highlightCardId);\n            \n            // Find the card index\n            const cardIndex = fetchedCards.findIndex((card: Card) => card.id === highlightCardId);\n            \n            // Calculate what page the card is on\n            if (cardIndex !== -1) {\n              const cardPage = Math.floor(cardIndex / CARDS_PER_PAGE) + 1;\n              \n              // Load all pages up to the card's page\n              if (cardPage > 1) {\n                const cardsToShow = fetchedCards.slice(0, cardPage * CARDS_PER_PAGE);\n                setVisibleCards(cardsToShow);\n                setCurrentPage(cardPage);\n                setHasMoreCards(cardPage * CARDS_PER_PAGE < fetchedCards.length);\n              }\n              \n              // Wait for rendering then scroll to the highlighted card\n              setTimeout(() => {\n                if (cardContainerRefs.current[cardIndex]?.current) {\n                  cardContainerRefs.current[cardIndex].current?.scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'center'\n                  });\n                }\n              }, 300);\n            }\n          }\n        }\n      } catch (err) {\n        setError('Failed to load cards');\n        setLoading(false);\n      }\n    };\n\n    fetchCards();\n  }, [deckId, location.state]);\n\n  const handleBackClick = () => {\n    navigate('/');\n  };\n\n  const handleTestClick = () => {\n    console.log(\"Starting test mode with all cards\");\n    \n    // Create a direct clone of cards to avoid API calls\n    try {\n      // Direct navigation with cards in state (avoid storage mechanisms)\n      console.log(`Directly passing ${cards.length} cards to test mode`);\n      navigate(`/test/${deckId}`, {\n        state: { \n          testMode: 'all',\n          cards: cards,  // Pass entire card array directly\n          deckId: deckId\n        }\n      });\n    } catch (err) {\n      console.error(\"Failed to start test mode:\", err);\n      // Fallback to simpler state\n      navigate(`/test/${deckId}`, { state: { testMode: 'all' } });\n    }\n  };\n\n  const handleStarredTestClick = () => {\n    console.log(\"Starting test mode with starred cards only\");\n    \n    // Save starred card IDs to localStorage for backup\n    localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, JSON.stringify(starredCardIds));\n    \n    try {\n      // Filter starred cards before navigation to avoid processing in TestMode\n      const starredCards = cards.filter(card => starredCardIds.includes(card.id));\n      console.log(`Found ${starredCards.length} starred cards to test`);\n      \n      // Direct navigation with filtered cards in state\n      navigate(`/test/${deckId}`, { \n        state: { \n          starredOnly: true,\n          cards: starredCards,  // Pass already filtered cards\n          starredCardIds: starredCardIds,\n          deckId: deckId\n        } \n      });\n    } catch (err) {\n      console.error(\"Failed to start starred test mode:\", err);\n      // Fallback to simpler state\n      navigate(`/test/${deckId}`, { \n        state: { starredOnly: true, starredCardIds: starredCardIds }\n      });\n    }\n  };\n\n  const handleFirstFlip = () => {\n    // When any card is flipped for the first time, hide instructions on all cards\n    setShowInstructions(false);\n    // Save preference to localStorage\n    localStorage.setItem('showFlipInstructions', 'false');\n  };\n\n  const handleFlipAll = () => {\n    const newFlipState = !areAllFlipped;\n    cardRefs.current.forEach(ref => {\n      if (ref.current) {\n        ref.current.flip(newFlipState);\n      }\n    });\n    setAreAllFlipped(newFlipState);\n  };\n\n  const handleCardInteraction = (cardId: string) => {\n    // Remove the highlighting when card is interacted with\n    setHighlightedCardId(null);\n  };\n\n  // Add a recovery function for starred cards\n  const recoverStarredCards = () => {\n    try {\n      console.log('Attempting to recover starred cards from backup');\n      \n      // Try to get the backup\n      const backupStarred = localStorage.getItem('asl_study_tool_starred_cards_backup');\n      if (backupStarred) {\n        const parsedBackup = JSON.parse(backupStarred);\n        if (parsedBackup && parsedBackup.length > 0) {\n          console.log(`Found backup with ${parsedBackup.length} starred cards`);\n          \n          // Restore to main storage\n          localStorage.setItem(LOCAL_STORAGE_STARRED_KEY, backupStarred);\n          \n          // Update state\n          setStarredCardIds(parsedBackup);\n          \n          console.log('Successfully recovered starred cards from backup');\n          return true;\n        }\n      }\n      console.log('No valid backup found');\n      return false;\n    } catch (err) {\n      console.error('Error recovering starred cards from backup:', err);\n      return false;\n    }\n  };\n\n  if (loading) return (\n    <div className=\"loading-container\">\n      <div>Loading...</div>\n    </div>\n  );\n  \n  if (error) return (\n    <div className=\"error-container\">\n      <div>Error: {error}</div>\n    </div>\n  );\n\n  // Check if any cards are starred - add more debugging\n  const hasStarredCards = cards.some(card => starredCardIds.includes(card.id));\n  console.log(`Starred card IDs: ${starredCardIds.length > 0 ? starredCardIds.join(', ') : 'none'}`);\n  console.log(`Has starred cards: ${hasStarredCards}`);\n\n  return (\n    <div className=\"deck-container\">\n      <div className=\"back-button-container\">\n        <button className=\"back-button\" onClick={handleBackClick} title=\"Back to Home\">\n          &#8592;\n        </button>\n      </div>\n      \n      {/* Deck title */}\n      {deckId === 'all-starred' && (\n        <h1 className=\"deck-title\">All Starred Cards</h1>\n      )}\n      \n      <div className=\"deck-actions\">\n        <div className=\"action-buttons\">\n          <button className=\"deck-button\" onClick={handleFlipAll} title={areAllFlipped ? \"Show Videos\" : \"Show Answers\"}>\n            {areAllFlipped ? \"Show Videos\" : \"Show Answers\"}\n          </button>\n          <button className=\"deck-button\" onClick={handleTestClick} title=\"Start Test\">\n            Test All\n          </button>\n          {starredCardIds.length > 0 && (\n            <button \n              className=\"deck-button starred-test-button\" \n              onClick={handleStarredTestClick} \n              title=\"Test Starred Cards Only\"\n            >\n              Test Starred\n            </button>\n          )}\n          <button \n            className=\"deck-button debug-button\" \n            onClick={refreshStarredCards}\n            title=\"Debug: Refresh Starred Cards\" \n          >\n            Refresh Stars\n          </button>\n        </div>\n      </div>\n      \n      {/* Debug info */}\n      <div className=\"debug-info\" style={{ padding: \"10px\", background: \"#333\", margin: \"10px\", borderRadius: \"5px\", fontSize: \"12px\" }}>\n        <p>Starred IDs: {starredCardIds.length > 0 ? starredCardIds.join(', ') : 'None'}</p>\n        <p>Loading Starred: {loadingStarred ? 'Yes' : 'No'}</p>\n        <p>Deck Cards: {cards.length}</p>\n        <div style={{ display: \"flex\", gap: \"10px\", marginTop: \"5px\" }}>\n          <button onClick={refreshStarredCards} style={{ padding: \"5px\", fontSize: \"12px\" }}>\n            Refresh Stars\n          </button>\n          <button onClick={recoverStarredCards} style={{ padding: \"5px\", fontSize: \"12px\", background: \"#664646\", color: \"white\" }}>\n            Recover Starred\n          </button>\n        </div>\n      </div>\n      \n      <div className=\"cards-grid\">\n        {visibleCards.map((card, index) => {\n          const cardIndex = cards.findIndex(c => c.id === card.id);\n          const isCardStarred = starredCardIds.includes(card.id);\n          \n          return (\n            <div key={card.id} ref={cardContainerRefs.current[cardIndex]}>\n              <Flashcard\n                ref={cardRefs.current[cardIndex]}\n                videoUrl={card.video_url}\n                answer={card.answer}\n                showInstructions={showInstructions}\n                onFirstFlip={handleFirstFlip}\n                isHighlighted={card.id === highlightedCardId}\n                onCardInteraction={handleCardInteraction}\n                cardId={card.id}\n                isStarred={isCardStarred}\n                onStarToggle={handleStarToggle}\n              />\n            </div>\n          );\n        })}\n        \n        {/* Loading trigger element */}\n        {hasMoreCards && (\n          <div \n            ref={loadMoreTriggerRef} \n            className=\"load-more-trigger\"\n            style={{ width: '100%', height: '20px', margin: '20px 0' }}\n          >\n            {loading && <div className=\"loading-indicator\">Loading more cards...</div>}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Deck; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}